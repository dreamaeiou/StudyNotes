# 代码题

1. 阅读下面代码段，说出KeyScan()函数的功能，并对每行代码进行解释。

   ```c
   uint KeyScan(){
       if(KEY == 0){
           delay_ms(10);
           if(KEY == 0){
               while(!KEY);
               return 1;
           }
       }
       return 0;
   }
   ```

2. 请阅读以下代码段，回答： 

   （1）SampleApp_ProcessEvent函数何时触发。 

   （2）if (events & LED_TEST_EVT)何时为真，含义又是什么？

   （3）return(events^LED_TEST_EVT);语句作用是什么

   ```c
   #define LED_TEST_EVT 0x0002
   uint16 SampleApp_ProcessEvent(uint8 task_id, uint16 events){
       if (events & LED_TEST_EVT){
           HalLedBlink(HAL_LED_1, 0, 50, 1000);
           return(events^LED_TEST_EVT);
       }
   }
   ```

   ```
   解答：
   1.在操作系统的任务调度循环中被调用，当该任务的事件掩码events中有任意被置位时触发
   2.当events的第一位为1时，表达式结果非0，触发。表示当前有LED测试事件待处理
   3.通过异或翻转指定位，将LED_TEST_EVT对应的位从events中清除
   ```

3. 请阅读以下代码段，回答： 

   （1）程序下载后上电运行，串口输出的内容是什么？请解释原因。 

   （2）按键S1按下，串口输出的内容又是什么？请解释原因。

```c
void   SampleApp_Init(uint8 task_id){
  SampleApp_TaskID = task_id;
  //...
  HalUARTWrite(0,"1",   sizeof("1"));

}

uint16   SampleApp_ProcessEvent(uint8 task_id, uint16 events){
  if ( events & SYS_EVENT_MSG ){
      HalUARTWrite(0,"2",   sizeof("2"));
      process_sys_event_msg(task_id);
      return (events ^ SYS_EVENT_MSG);
  }
 
  if ( events & LED_TEST_EVT ){
    HalUARTWrite(0,"3",   sizeof("3"));
    HalLedSet(HAL_LED_1, HAL_LED_MODE_ON);
    return (events ^ LED_TEST_EVT);
  }

  if ( events & KEY_CHANGE_LED_EVT ){
    HalUARTWrite(0,"4",   sizeof("4"));
    HalLedSet(HAL_LED_1,   HAL_LED_MODE_TOGGLE);  
    return (events ^ KEY_CHANGE_LED_EVT);

  }}

void   process_sys_event_msg(uint8 task_id){
  //...
  while ( MSGpkt ){
    switch ( MSGpkt->hdr.event ){
      case ZDO_STATE_CHANGE:
        SampleApp_NwkState =   (devStates_t)(MSGpkt->hdr.status);
        if (SampleApp_NwkState ==   DEV_ZB_COORD){
          HalUARTWrite(0,"5",   sizeof("5"));
          osal_set_event(task_id,   LED_TEST_EVT);
        }
        break;
      case KEY_CHANGE:
        HalUARTWrite(0,"6",   sizeof("6"));
        SampleApp_HandleKeys( ((keyChange_t   *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
        break;
  //...}   

void   SampleApp_HandleKeys(uint8 shift, uint8 keys){
  //...
  osal_set_event(SampleApp_TaskID,   KEY_CHANGE_LED_EVT);

}
```

```
解答：
（1）1253. 程序下载后上电运行，首先SampleApp_Init()，会打印1；由于上电后协调器自动创建网络，会触发系统事件，于是执行SampleApp_ProcessEvent()，匹配到SYS_EVENT_MSG ，打印2；接着执行process_sys_event_msg()，匹配到ZDO_STATE_CHANGE，打印5，并触发了LED_TEST_EVT事件；于是继续执行SampleApp_ProcessEvent()，匹配到LED_TEST_EVT，打印3.
（2）264
```

4. 请阅读以下代码段，程序下载到协调器后上电运行，串口0输出的数字顺序是什么？请解释原因。

```c
uint8 flag = 1;

void SampleApp_Init(uint8 task_id) {
    // ...
    HalUARTWrite(0, "1", sizeof("1"));
}

uint16 SampleApp_ProcessEvent(uint8 task_id, uint16 events) {
    if (events & SYS_EVENT_MSG) {
        HalUARTWrite(0, "2", sizeof("2"));
        process_sys_event_msg(task_id);
        return (events ^ SYS_EVENT_MSG);
    }
    return 0;  
}

void process_sys_event_msg(uint8 task_id) {
    // ...
    while (MSGpkt) {
        switch (MSGpkt->hdr.event) {
            case ZDO_STATE_CHANGE:
                SampleApp_NwkState = (devStates_t)(MSGpkt->hdr.status);
                if (SampleApp_NwkState == DEV_ZB_COORD) {
                    HalUARTWrite(0, "3", sizeof("3"));
                    HalUARTWrite(1, AT_C, sizeof(AT_C));
                }
                break;

            case CMD_SERIAL_MSG:
                process_serial_data((mtOSALSerialData_t *)MSGpkt);
                break;

            // ... 其他 case
        }
    }
}

void process_serial_data(mtOSALSerialData_t *cmdMsg) {
    HalUARTWrite(0, "4", sizeof("4"));

    switch (flag) {
        case 1: // 设置WiFi工作模式
            if (strstr((char const *)(&cmdMsg->msg[1]), "OK")) {
                HalUARTWrite(1, CWMODE_C, sizeof(CWMODE_C));
                HalUARTWrite(0, "5", sizeof("5"));
                flag = 2;
            }
            break;

        case 2: // 连接WiFi
            if (strstr((char const *)(&cmdMsg->msg[1]), "OK")) {
                char str_cmd[100];
                sprintf(str_cmd, "AT+CWJAP=\"%s\",\"%s\"\r\n", LYSSID, LYPASSWD);
                HalUARTWrite(1, (unsigned char *)str_cmd, strlen(str_cmd));
                HalUARTWrite(0, "6", sizeof("6"));
                flag = 3;
            }
            break;

        // ... 其他 case
    }
}
```

```
解答：
12324524624
"1"：SampleApp_Init() 在初始化时输出。
第一次 "2"：收到 SYS_EVENT_MSG，进入 SampleApp_ProcessEvent。
"3"：处理 ZDO_STATE_CHANGE 事件，协调器组网成功（DEV_ZB_COORD）。
第二次 "2"：ESP8266 返回 "OK"（对 AT_C 的响应），触发新 CMD_SERIAL_MSG 事件。
"4" → "5"：process_serial_data() 执行，flag=1，匹配 "OK"，发送 CWMODE_C，flag 变为 2。
第三次 "2"：ESP8266 对 CWMODE_C 返回 "OK"，再次触发 CMD_SERIAL_MSG。
"4" → "6"：flag=2，匹配 "OK"，发送连接 WiFi 命令，flag 变为 3。
后续 "2"、"4"：可能因连接响应或其他串口消息继续触发事件，但 flag=3 后无对应处理，仅输出 "2"（事件入口）和 "4"（进入 process_serial_data）。
```

