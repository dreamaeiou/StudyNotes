

# 数据结构与算法

## 绪论

```
算法：为了解决某类问题规定的有限长的操作序列
特征：有穷性 确定性 可行性 有输入 有输出
```



## 复杂度分析

### 1.迭代与递归

```
迭代：For循环 While循环 嵌套循环...
```

```
递归：函数自身调用自身
1.调用栈    --函数每次调用自身都会开辟新的内存空间，到函数返回后才会释放。
2.尾递归    --函数在返回前的最后一步进行递归调用，无需保留上一层函数上下文。
3.递归树	 --“分治”类问题
```

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\循环迭代对比.png)

### 2.时间复杂度

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\时间复杂度比较.png)

```
时间复杂度：指的不是算法运行的时间,而是算法时间随数据量增长的趋势

推算方法：
1.统计操作数量
·忽略函数中的常数项    5n+3 => O(n)
·省略所有的系数    2n^2 => O(n^2)
·循环嵌套使用乘法

2.判断渐进上界
·时间复杂度由函数中最高阶决定    2^n + n^3 + 10n^2 + 100n => O(2^n)

3.最差最佳平均时间复杂度
·取决于数据的分布
```



### 3.空间复杂度

```
空间复杂度：指衡量算法占用内存空间随着数据量变大时的增长趋势(输出空间 暂存空间)
通常算法在运行过程中使用的内存空间包括：输入空间 输出空间 暂存空间(暂存数据 栈帧空间 指令空间)
```

```java
/* 类 */
class Node {
    int val;
    Node next;
    Node(int x) { val = x; }
}

/* 函数 */
int function() {
    // 执行某些操作...
    return 0;
}

int algorithm(int n) {        // 输入数据
    final int a = 0;          // 暂存数据（常量）
    int b = 0;                // 暂存数据（变量）
    Node node = new Node(0);  // 暂存数据（对象）
    int c = function();       // 栈帧空间（调用函数）
    return a + b + c;         // 输出数据
}
```

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\空间复杂度比较.png)

```
推算方法：
1.以最差输入数据为标准
2.以算法运行中内存峰值为标准
```



## 数据结构

### 1.数据结构分类

```
逻辑结构：
线性数据结构    --数组 链表 栈 队列 哈希表
非线性数据结构(树形 网状形)    --树 堆 图 哈希表
```

```
物理结构：
连续与分散
```

```
所有数据结构都是基于数组和链表实现的
```

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\物理结构连续与分散.png)



### 2.基本数据类型

```
基本数据类型：是可以直接用于CPU运算的类型 由二进制存储在内存中

byte short int long float double boolen char...

1bit 最大值127(0111 1111) 最小值-128(补码1000 0000)
```



### 3.数字编码

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\原码补码反码.png)

```
概念：
原码    --一字节长数据的二进制表示 最高位是符号位 0是正 1是负
反码    --为了负数运算产生(减法) 对原码除符号位外取反
补码    --为了统一+0与-0 对反码最后一位加一
```

```
浮点数编码：(FAQs:为什么int float同样是四字节长 表示范围却不一样)
https://www.hello-algo.com/chapter_data_structure/number_encoding/#331
```



### 4.字符编码

```
https://www.hello-algo.com/chapter_data_structure/character_encoding/#341-ascii

ASCII => GBK => Unicode => UTF-8

字符在计算机中存储编码与网络中传输的编码是不同问题。
网络传输中常使用UTF-8来实现最优传输效率。
```



## 线性表

```
概念：
描述了一组有序的数据项集合 其中每个数据项都有一个前驱和一个后继(除了第一个和最后一个)
线性表本身不是一种数据结构 是抽象的概念具有一类功能的接口
```

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\链表.png)

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\广义表.png)

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\稀疏矩阵的十字链表表示.png)



```
顺序表：逻辑上相邻的元素在物理地址上也相邻
链表：逻辑上相邻的元素在物理地址上可以不相邻
=>双向链表    --与单链表相比有一个尾指针
=>循环链表
=>广义表    --长度深度 E=(a, (a,b), d, e, ((i, j, l),k)) 长5深3
=>十字链表    --稀疏矩阵的链式存储(https://blog.csdn.net/2301_80035594/article/details/135540435)
```



## 树

### 1.基础

```
术语：
根节点：位于二叉树的顶层节点 没有父节点
叶节点：没有子节点的节点 两个指针均指向None
边：连接两个节点的线段 即节点的引用(指针)
层：从顶至底递增 根节点的层是1
度：节点的子节点数量(0 1 2)
二叉树的高度：从根节点到最远叶节点经过边的数量
节点的深度：从根节点到该节点所经过边的数量
```

```
1.完美二叉树(满二叉树)    --所有层的子节点都被填满
2.完全二叉树    --只有最底层的节点未被填满 且最底层的节点尽量靠左填充
3.完满二叉树    --除了叶节点之外 其余所有的节点都有两个子节点
4.平衡二叉树    --左子树和右子树的高度差不超过1
```

### 2.遍历

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\二叉树的前中后序遍历.png)

```
1.层序遍历(广度优先遍历)    --从上至下从左至右遍历
2.前序遍历(深度优先遍历)
3.中序遍历(深度优先遍历)
4.后序遍历(深度优先遍历)
```



### 3.二叉搜索树

``` 
1.对于根节点 左子树所有节点的值 < 根节点的值 < 右子树所有节点的值
2.任意节点的左右子树也是二叉搜索树
```

```
二叉搜索树的中序遍历的序列是升序的
```



### 4.自平衡二叉查找树/AVL树

```
术语：
节点高度：该节点到最远叶节点经过边的数量 叶节点高度为0 空节点高度为-1
节点平衡因子：左子树高度减去右子树高度 空节点平衡因子为0
```

```
特征：
通过旋转让失衡的而二叉搜索树重新变成平衡二叉树 平衡因子的绝对值 > 1的节点为失衡节点
```

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\AVL树旋转.png)

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\AVL树旋转选择.png)

### 5.多叉树/B树

```
详见https://www.cnblogs.com/lianzhilei/p/11250589.html
```



### 6.红黑树

```

```



### 7.堆

```
堆：堆是一种满足特定条件的完全二叉树
小顶堆：任意节点值 <= 其子节点值
大顶堆：任意节点值 >= 其子节点值
堆顶：根节点
堆底：底层最靠右侧的节点
```



## 图

### 1.基础

```
图：图G有若干点和连接点的边组成 点的集合称为点集V 边集合E 记G=(v,E)
阶：图G的点数|V|称为阶 记作|G|
度：指一个顶点拥有的边数 入度指多少边指向该顶点 反之
环/回路：起点等于终点的路径    --用拓扑排序判断有向图中是否存在环

设图定点数n，边数e
有向图：0<=e<=n(n+1)
无向图：0<=e<=n(n+1)/2

有向图表示：G=(V,E) V={V1,V2,V3,V4} E={<V1,V2>,<V1,V3>,<V3,V4>,<V4,V1>} --尖括号有向
无向图表示：G=(V,E) V={V1,V2,V3} E={(V1,V2),(V2,V3),(V1,V3)} --圆括号无向
```

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\图的邻接矩阵表示.png)

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\新图的邻接表表示.png)

### 2.广度/深度优先遍历

```
学习网站：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
图的每一部分都跟着网站演示一遍！！！
```

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\BFS.png)

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\DFS.png)



### 3.连通图

```
连通图：在一个图中任意一个顶点都至少与另一个顶点相连接
https://zhuanlan.zhihu.com/p/347908916

无向图：
极大连通子图：
极小连通子图：

有向图：
强连通：有向图中顶点a和b之间存在双向路径 则ab连通
强连通图：有向图中任意两顶点均强连通
强连通分量：有向图的极大强连通子图
https://www.cnblogs.com/McGeeForest/p/12176900.html
```



### 4.生成树

```
生成树：是一个连通图G的一个极小连通子图 G个顶点 G-1条边

n个顶点的图形围成的环有n棵生成树

最小生成树：带权连通无向图的生成树中 边的权值和最小的树

最小生成树算法：https://blog.csdn.net/the_ZED/article/details/105938353
Prim普里姆算法：根据所选顶点最小权重的边搜索其他邻接顶点 适合稠密图
Kruskal克鲁斯卡尔算法：根据最小权边入手找相邻节点使其连接 适合稀疏图
```

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\最小生成树.png)

### 5.最短路径问题

```
带权有向图的最短路径
Dijkstra算法：https://blog.csdn.net/xiaoyuuoo/article/details/144031101
```



### 6.关键路径问题

```
AOE网：带权的有向无环图 顶点-事件 弧-活动 权-活动持续时间
源点：工程开始点  --入度0
汇点：工程结束点  --出度0
关键路径：有向图源点到汇点的最长路径
关键活动：关键路径的长度即最短工期
```



## 搜索/查找

### 1.基础

```
分类：
1.静态查找：用于只读数据集 不会对表元素进行插入删除(顺序查找 二分查找 索引查找)
2.动态查找：查找内容伴随查找过程变化(二叉搜索树 AVL树 B树 红黑树 哈希表)
3.外查找：数据量大通过磁盘查找(B+树)
4.内查找：数据量小在RAM中查找

ASL平均查找长度：Pi-查找第i个元素的概率 Ci-查找第i个元素需要比较的次数
```



### 2.顺序查找

```
给定值与顺序表中记录关键字值比较

时间复杂度：最好O(1) 最坏O(n) 平均O(n)
```

$$
等概率情况下ASL = \frac{1}{n} \sum_{i=1}^{n} (n - i + 1) = \frac{n + 1}{2}
$$



### 3.二分查找/折半查找

```
适用条件为有序表
```

$$
ASL = \frac{1}{n} \sum_{i=1}^{n} C_i = \frac{1}{n} \left[ \sum_{j=1}^{h} j \times 2^{j-1} \right] = \frac{n + 1}{n} \log_2(n + 1) - 1 \approx \log_2(n + 1) - 1
$$



### 4.索引查找/分块查找

```
https://www.cnblogs.com/nnngu/p/8290367.html
```



### 5.散列查找/哈希查找

```
哈希函数：在关键字与表中存储位置之间建立函数关系 H(key)作为关键字为key在记录在表中的位置 --关键字集合映射到地址集合
哈比表：地址空间存储的数据集合

理想情况ASL接近O(1) 最坏退化成O(n)
```

```
哈希函数要求计算简单 关键字到地址的映射冲突少
常见构造方法如下：
1.直接定址法 -- H(key)=key || H(key)=akey+b 适用于地址集合关键字集合大小相等
2.数字分析法 -- 对关键字进行分析 取关键字的若干位或组合作为地址 适用于预估关键字每一位出现频率
3.平方取中法 -- H(key)=key^2的中间几位 适用于关键字位数较短情况
4.折叠法 -- 关键字位数较长 将关键字分割成位数相等的几部分再相加 适用于关键字位数较长情况
5.除留余数法 -- H(key)=key MOD p(p<=m) 取关键字不大于哈希表长度m除以p的余数作为地址
6.随机数法 -- H(key)=random(key)
```

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\数字分析法.png)

```
解决哈希冲突的方法：
1.开放寻址法 --线性探测探测散列H(key)=(H(key)+d)%m 平方(二次)探测散列 随机数探测散列
2.再哈希法
3.链接法
4.公共溢出区法

*负载因子 = 哈希表中的元素数量 / 哈希表的槽位总数 越接近1越容易冲突 反之
```

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\线性探测例题.png)

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\链地址法.png)

### 6.二叉搜索树/二叉查找树/BST

```
特点：
1.中序遍历二叉排序树可以得到关键字有序序列
2.拥有折半查找的特性 采用链表存储 是动态查找表的一种适宜表示

良好的BST ASL为O(logn) 不平衡接近O(n)
```



## 排序

### 1.基础

```
评价维度：
运行效率：时间复杂度低操作数量少为佳
就地性：在原数组排序无需借助辅助数组为佳
稳定性：排序完成后相等元素在数组中的相对顺序不改变
自适应性：利用输入数据已用顺序减少计算量
是否基于比较：依赖比较运算符排序数组理论最优时间复杂度O(nlogn) 不使用复杂度可达O(n)但通用性差
```



### 2.冒泡排序

```
连续地比较与交换相邻元素实现排序 时间复杂度O(n)=n^2
```



### 3.快速排序

```
选择数组中的某个元素作为"基准数" 将所有小于基准数的元素移到其左侧 而大于基准数的元素移到其右侧 时间复杂度O(n)=nlogn
```

   

### 4.选择排序

```
从未排序区间中取出最小元素插入到已排序区间的末尾 时间复杂度O(n)=n^2
```



### 5.堆排序

```
建立小顶堆 不断执行出堆操作 一次记录出堆元素 即可获得从小到大排列序列
```



### 6.插入排序

```
在未排序区间选择一个基准元素 逐一与左侧已排序区间比较大小 插入到正确的位置 时间复杂度O(n)=n^2
```



### 7.归并排序

```
通过递归将数组从中点处分来 当子数组长度为1停止划分开始合并 持续地将左右两个较短有序组合合并成较长有序组合 时间复杂度O(n)=nlogn
```



### 8.比较

![](C:\Users\xionghongrui\Desktop\数据结构与算法理论基础\img\排序复杂度比较.png)
